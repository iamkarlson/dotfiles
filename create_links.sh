#!/usr/bin/env bash
#
# Purpose of this file is to create symlinks to configuration files I have in my repo.
# Because directory links have to be created with root privileges,
# this file has to be run with root or sudo

set -e

target="$1"
HOME=$target
src="$target/src"
dotfiles="$src/dotfiles"
config="$target/.config"

read -p "Clear screen? [c] to clean, any other key to continue" -n 1 -r
echo # (optional) move to a new line
if [[ $REPLY =~ ^[c]$ ]]; then
    echo "Clearing screen..."
    clear
fi

echo "setting up links from $dotfiles"
echo "targeting into $target"
read -p "Are you sure? " -n 1 -r
echo # (optional) move to a new line
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
	exit 1
fi

# 0. links creation functions
echo "#!/usr/bin/env bash" >remove_links.sh
echo "#" >>remove_links.sh
echo "###################################################################" >>remove_links.sh
echo "# Autogenerated remove links file" >>remove_links.sh
echo "###################################################################" >>remove_links.sh
echo "" >>remove_links.sh
echo "function delete_link(){" >>remove_links.sh
echo "	[-h \$1] && rm -i \$1" >>remove_links.sh
echo "}" >>remove_links.sh
echo "" >>remove_links.sh

function log_warning() {
	# coloring output message in yellow
	echo -n "$(tput setaf 3)"
	echo "$1"
	# reset to terminal defaults
	echo -n "$(tput sgr0)"
}

function log_info() {
	# coloring output message in green
	echo -n "$(tput setaf 2)"
	echo -n "$1"
	# reset to terminal defaults
	echo "$(tput sgr0)"
}

function ln_file() {
	echo "linking file from $1 to $2"
	(ls $2 >>/dev/null 2>&1 && log_warning "File $2 exists") || (ln -s $1 $2 && log_info "File $2 created!")
	echo "# Removing file -------------------------------------- $2" >>remove_links.sh
	echo "delete_link \"$2\"" >>remove_links.sh
}

function ln_directory() {
	echo "linking directory from $1 to $2"
	(ls $2 >>/dev/null 2>&1 && log_warning "$2 exists") || (ln -ds $1 $2 && log_info "Directory $2 created!")
	echo "# Removing directory ********************************* $2" >>remove_links.sh
	echo "delete_link \"$2\"" >>remove_links.sh
}
function delete_link() {
	[-h $1] && rm -i $1
}

function copy_user_config() {
	local source="$1"
	local destination="$2"
	local dest_dir
	dest_dir=$(dirname "$destination")

	echo "copying user config from $source to $destination"
	mkdir -p "$dest_dir"

	if [ -e "$destination" ]; then
		log_warning "Destination $destination exists, overwriting"
	fi

	if [ -d "$source" ]; then
		cp -r "$source" "$destination" && log_info "Directory $destination copied!"
	else
		cp "$source" "$destination" && log_info "File $destination copied!"
	fi

	echo "# Removing copied user config >>> $destination" >>remove_links.sh
	echo "[ -d \"$destination\" ] && rm -ri \"$destination\"" >>remove_links.sh
	echo "[ -f \"$destination\" ] && rm -i \"$destination\"" >>remove_links.sh
}

function copy_system_config() {
	local source="$1"
	local destination="$2"
	local dest_dir
	dest_dir=$(dirname "$destination")

	echo "copying system config from $source to $destination"
	sudo mkdir -p "$dest_dir"

	if sudo test -e "$destination"; then
		log_warning "Destination $destination exists, overwriting"
	fi

	if [ -d "$source" ]; then
		sudo cp -r "$source" "$destination" && log_info "Directory $destination copied!"
	else
		sudo cp "$source" "$destination" && log_info "File $destination copied!"
	fi

	echo "# Removing copied system config >>> $destination" >>remove_links.sh
	echo "sudo [ -d \"$destination\" ] && sudo rm -ri \"$destination\"" >>remove_links.sh
	echo "sudo [ -f \"$destination\" ] && sudo rm -i \"$destination\"" >>remove_links.sh
}

# Create user home .config

mkdir -p $config

# Git configuration
echo "creating git config at $target/git"
ln_directory "$dotfiles/git/git" $target/git

ln_file "$dotfiles/git/system.gitconfig" "$target/.gitconfig"
ln_file "$dotfiles/git/global.gitignore" "$target/.gitignore"

#
# Onedrive syncer
# URL: https://github.com/abraunegg/onedrive
#

mkdir -p $config/onedrive

ln_file $dotfiles/onedrive/onedrive.config $config/onedrive/config
ln_file $dotfiles/onedrive/sync_list.config $config/onedrive/sync_list

# Zsh settings

ln_directory "$dotfiles/zsh/scripts" "$target/.zsh"

(ls $target/.zsh/private.zshrc >>/dev/null 2>&1 && echo "private zshrc exists") || touch $target/.zsh/private.zshrc

ln_file "$dotfiles/zsh/.shellrc" "$target/.shellrc"
ln_file "$dotfiles/zsh/.zshrc" "$target/.zshrc"
ln_file "$dotfiles/zsh/.zprofile" "$target/.zprofile"
ln_file "$dotfiles/zsh/.p10k.zsh" "$target/.p10k.zsh"

# Zsh plugins
ln_file "$dotfiles/zsh/plugins.txt" "$target/.zsh_plugins.txt"
ln_file "$dotfiles/zsh/plugins.zsh" "$target/.zsh_plugins.zsh"

ln_file "$dotfiles/tasks/global-tasks.yml" "$target/taskfile.yml"
ln_file "$dotfiles/tasks/taskfile.env" "$target/taskfile.env"
ln_file "$dotfiles/tasks/private-tasks.yml" "$target/private-tasks.yml"

#
# Tmux
#

ln_file $dotfiles/.tmux.conf $target/.tmux.conf

#
# Espanso text expander
# URL: https://espanso.org
#

ln_directory "$dotfiles/espanso" "$config/espanso"
ln_directory "$dotfiles/thefuck" "$config/thefuck"


mkdir -p $config/kitty
ln_file $dotfiles/kitty/kitty.conf $config/kitty/kitty.conf

function alacritty() {
	#mkdir -p $config/alacritty
	ln_directory $dotfiles/alacritty $config/alacritty
}

alacritty

function vim() {
	ln_file $dotfiles/vim/.vsvimrc $target/.vsvimrc
	ln_file $dotfiles/vim/.ideavimrc $target/.ideavimrc
	ln_file $dotfiles/vim/.vimrc $target/.vimrc

	ln_file $dotfiles/vim/.gvimrc $target/.gvimrc

	mkdir -p $config/nvim

	ln_file $dotfiles/vim/init.vim $config/nvim/init.vim

	mkdir $target/.vim
	mkdir $target/.vim/backup_files
	mkdir $target/.vim/swap_files
	mkdir $target/.vim/undo_files

	ln_file $dotfiles/vim/autocmd.vimrc $target/.vim/autocmd.vimrc
	ln_file $dotfiles/vim/plugin-settings.vimrc $target/.vim/plugin-settings.vimrc
	ln_file $dotfiles/vim/ide.vimrc $target/.vim/ide.vimrc
	ln_file $dotfiles/vim/simple-mapping.vimrc $target/.vim/simple-mapping.vimrc
	ln_file $dotfiles/vim/mapping.vimrc $target/.vim/mapping.vimrc
	ln -ds $dotfiles/vim/plugins $target/.vim/plugins
}

#vim

function autocomplete() {
	# generating shell completions for tools
	kubectl completion zsh >$target/.zsh/completions/_kubectl
	helm completion zsh >$target/.zsh/completions/_helm
	k3d completion zsh >$target/.zsh/completions/_k3d
	minikube completion zsh >$target/.zsh/completions/_minikube
}

#(ls ~/.autoenv >> /dev/null 2>&1 && echo "autoenv already installed") || git clone git@github.com:hyperupcall/autoenv.git ~/.autoenv

# XDG configuration
ln_file $dotfiles/xdg/user-dirs.dirs $config/user-dirs.dirs
ln_file $dotfiles/xdg/mimeapps.list $config/mimeapps.list

ln_directory $dotfiles/paru $config/paru

ln_file $dotfiles/waybar/config $config/waybar/config
ln_file $dotfiles/waybar/style.css $config/waybar/style.css

ln_directory $dotfiles/rofi $config/rofi

ln_directory $dotfiles/swaync $config/swaync

ln_directory $dotfiles/swappy $config/swappy

ln_directory $dotfiles/workstyle $config/workstyle

ln_directory $dotfiles/hyprland $config/hypr

# hyprwhenthen - event-driven window automation
# Install: paru -S hyprwhenthen-bin
ln_directory $dotfiles/hyprwhenthen $config/hyprwhenthen

# VSCode settings

ln_file $dotfiles/vscode/settings.json $config/Code/User/settings.json
ln_file $dotfiles/vscode/keybindings.json $config/Code/User/keybindings.json
ln_file $dotfiles/vscode/mcp.json $config/Code/User/mcp.json

#
# Hyprland config
#

#copy_system_config "$dotfiles/hyprland/hyprland.sh" "/usr/bin/hyprland_launcher"
copy_system_config "$dotfiles/hyprland/hyprland.desktop" "/usr/share/wayland-sessions/hyprland.desktop"
copy_system_config "$dotfiles/hyprland/hyprlock-before-sleep@.service" "/etc/systemd/system/hyprlock-before-sleep@.service"
copy_system_config "$dotfiles/hyprland/hyprlock-after-sleep@.service" "/etc/systemd/system/hyprlock-after-sleep@.service"
copy_system_config "$dotfiles/hyprland/scripts/lock-resume-on-sleep.sh" "/root/scripts/lock-resume-on-sleep.sh"

# Vivaldi configuration
ln_file $dotfiles/vivaldi/vivaldi-stable.conf $config/vivaldi-stable.conf

# link desktop files

# To override default desktop files you can create a .desktop file with the same name in ~/.local/share/applications
# Arch by default uses /usr/share/applications

for file in $dotfiles/desktop/*.desktop; do
	ln_file $file $target/.local/share/applications/$(basename $file)
done

mkdir -p $target/.config/systemd/user
for file in $dotfiles/services/*; do
	copy_user_config "$file" "$target/.config/systemd/user/$(basename "$file")"
done

# Thunderbird and Firefox are bastards. There's no way to customize their look without hacking the css files
# To make things worse, it's not really possible to get profile path from the command line easily
# grep "Path=" ~/.thunderbird/profiles.ini | sed 's/^Path=//'
#
# I will try linking the whole thunderbird dir to this path from search command above, let's see if it works on all machines

thunderbird_profile=$(grep "Path=" ~/.thunderbird/profiles.ini | sed 's/^Path=//')

if [ -z "$thunderbird_profile" ]; then
	log_warning "Thunderbird profile not found"
else
	ln_directory $dotfiles/thunderbird $target/.thunderbird/$thunderbird_profile/chrome
fi
